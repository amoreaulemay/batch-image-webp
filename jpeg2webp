#!/bin/bash

# pragma SPINNER.SH
# Author: Tasos Latsas

function _spinner() {
    local on_success="DONE"
    local on_fail="FAIL"
    local green="\e[32m"
    local red="\e[31m"
    local nc="\e[0m"

    case $1 in
        start)
            # calculate the column where spinner and status msg will be displayed
            column=$(($(tput cols)-${#2}-8))
            # display message and position the cursor in $column column
            echo -ne "${2}"
            printf "%${column}s"

            # start spinner
            i=1
            sp='\|/-'
            delay=${SPINNER_DELAY:-0.15}

            while :
            do
                printf "\b%b" "${sp:i++%${#sp}:1}"
                sleep "$delay"
            done
            ;;
        stop)
            if [[ -z ${3} ]]; then
                echo "spinner is not running.."
                exit 1
            fi

            kill "$3" > /dev/null 2>&1

            # inform the user uppon success or failure
            # echo -en "\b["
            if [[ $2 -eq 0 ]]; then
                printf "${green}%s${nc}" "${on_success}"
            else
                printf "${red}%s${nc}" "${on_fail}"
            fi
            printf "]\n"
            ;;
        *)
            echo "invalid argument, try {start/stop}"
            exit 1
            ;;
    esac
}

function start_spinner {
    # $1 : msg to display
    _spinner "start" "${1}" &
    # set global spinner pid
    _sp_pid=$!
    disown
}

function stop_spinner {
    # $1 : command exit status
    _spinner "stop" "$1" $_sp_pid
    unset _sp_pid
}

# pragma MAIN PROGRAM
# Copyright (c) 2021 Alexandre Moreau-Lemay
# Author : Alexandre Moreau-Lemay
# License : AGPL-3.0 License

clear
printf "This program will convert jpeg in a provided directory to webp, then make two directories (if they don't already exist) - jpeg and webp - and move the files according to their extensions.\n"

# pragma 1. Check if Homebrew is installed
start_spinner "1. Making sure HomeBrew is installed."
which -s brew
if ! which -s brew ; then
    # Install Homebrew
    ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
else
    brew update
    brew upgrade
fi
stop_spinner $?

# pragma 2. Check if ImageMagick is installed
start_spinner "2. Making sure ImageMagick is installed."
if brew ls --versions imagemagick > /dev/null; then
    printf "\e[32m    ImageMagick is installed.\n\e[39m"
else
    brew install imagemagick
fi
stop_spinner $?

# pragma 3. Check if coreutils is installed
start_spinner "3. Making sure coreutils is installed."
if brew ls --versions coreutils > /dev/null; then
    printf "\e[32m    coreutils is installed.\n\e[39m"
else
    brew install coreutils
fi
stop_spinner $?

# pragma 4. Make sure NPM is installed
start_spinner "4. Making sure NodeJS is installed."
if which node > /dev/null
    then
        printf "\e[32m    NodeJS is installed, going to the next step.\n\e[39m"
    else
        printf "\e[31m    You first need to install NodeJS.\n\e[39m"
        brew install node
fi
stop_spinner $?

# pragma 5. Make sure the jpeg converter script is installed
printf "5. Making sure the npm dependecies are installed, and installing them if not. This step might require administrative priviledges (enter your password if requested).\n"
npm list -g | grep webp-converter-cli || sudo npm install -g webp-converter-cli

# pragma 6. Getting the path of the conversion
if [ $# -eq 0 ]; then
    printf "6. Please enter the path for the directory with the files.\n"
    read -r path
else
    path="$1"
fi

# pragma 7. Check if the directory exists and move to the directory if it does
if [ ! -d "$path" ]; then
    printf "\e[31mThe path is invalid!\n"
    exit 1
else
    cd "$path" || exit
fi

# pragma 8. Infos about the album
printf "Enter the name of the album: "
read -r ALBUM_NAME

printf "Enter a description for the album: "
read -r ALBUM_DESCRIPTION

printf "Enter the year of the album: "
read -r ALBUM_YEAR

printf "Enter the city of the album: "
read -r ALBUM_CITY

printf "Enter the country of the album: "
read -r ALBUM_COUNTRY

# pragma 9. Select the album cover
function album_cover() {
    TEMP=true
    while "$TEMP"
    do
        printf "Please provide the name of the file (including the extension) : "
        read -r COVER_FILE_NAME
        if [ ! -f "$COVER_FILE_NAME" ]; then
            printf "Error: The file name provided does not exist. Would you like to try again? [y/n] : "
            read -r ALBUM_COVER_TRY_AGAIN
            if [ "$ALBUM_COVER_TRY_AGAIN" = "n" ] || [ "$ALBUM_COVER_TRY_AGAIN" = "N" ]; then
                printf "The program will therefore choose a random file.\n"
                random_album_cover
                TEMP=false
            fi
        else
            TEMP=false
        fi
    done
}

function random_album_cover() {
    COVER_FILE_NAME=$(find . -maxdepth 1 | gshuf -n 1 | cut -c 3-)
}

TEMP_T=true
while "$TEMP_T"
do
    printf "Do you wish to set a cover image for the album? If none is set, it will be randomly generated. [y/n] : "
    read -r _SET_ALBUM_COVER
    case "$_SET_ALBUM_COVER" in
        "y")
            album_cover
            TEMP_T=false
            ;;
        "Y")
            album_cover
            TEMP_T=false
            ;;
        "n")
            random_album_cover
            TEMP_T=false
            ;;
        "N")
            random_album_cover
            TEMP_T=false
            ;;
        *)
            printf "Invalid input! Please try again.\n"
            ;;
    esac
done

# pragma 10. Making the base of the json file
touch album.json
{
    printf "{\n"
    printf "    \"name\":\"%s\",\n" "$ALBUM_NAME"
    printf "    \"description\":\"%s\",\n" "$ALBUM_DESCRIPTION"
    printf "    \"year\":%s,\n" "$ALBUM_YEAR"
    printf "    \"city\":\"%s\",\n" "$ALBUM_CITY"
    printf "    \"country\":\"%s\",\n" "$ALBUM_COUNTRY"
    printf "    \"pictures\":[\n"
} >> album.json

# pragma 11. Making the two permanent directories and one temporary one
TEMP=$(uuidgen)
mkdir -p webp
mkdir -p jpeg
mkdir -p originals
mkdir "$TEMP"

# pragma 12. Executing the conversion script
mv -n ./*.jpg "$TEMP"/
mv -n ./*.jpeg "$TEMP"/ 2>/dev/null
cd "$TEMP"/ || exit

start_spinner 'Resizing files...'
for FILE in *
do
    if [ -f "$FILE" ];then
        ID=$(uuidgen)
        EXTENSION=${FILE#*.}
        if [ "$FILE" = "$COVER_FILE_NAME" ]; then
            COVER_ID="$ID"
        fi
        mv "$FILE" "$ID"."$EXTENSION"
        NEW_FILE="$ID"."$EXTENSION"
        printf "        \"%s\",\n" "$ID" >> ../album.json
        convert "$NEW_FILE" -resize 2000x2000\> -strip -interlace Plane -gaussian-blur 0.05 -quality 80% -density 72 "$ID-2000.$EXTENSION"
        convert "$NEW_FILE" -resize 1500x1500\> -strip -interlace Plane -gaussian-blur 0.05 -quality 80% -density 72 "$ID-1500.$EXTENSION"
        convert "$NEW_FILE" -resize 1000x1000\> -strip -interlace Plane -gaussian-blur 0.05 -quality 80% -density 72 "$ID-1000.$EXTENSION"
        convert "$NEW_FILE" -resize 500x500\> -strip -interlace Plane -gaussian-blur 0.05 -quality 80% -density 72 "$ID-500.$EXTENSION"
        mv -n "$NEW_FILE" ../originals/
    fi
done
stop_spinner $?

# pragma 13. Closing the album.json file and removing the last comma and line break from the loop
if     [ -n "$(tail -c1 ../album.json)" ]    # if the file has not a trailing new line.
then
       gtruncate -s-1 ../album.json           # remove one char as the question request.
else
       gtruncate -s-2 ../album.json           # remove the last two characters
       echo "" >> ../album.json              # add the trailing new line back
fi

{
    printf "    ],\n"
    printf "    \"cover\":\"%s\",\n" "$COVER_ID"
    printf "    \"sizes\":[\n"
    printf "        500,\n"
    printf "        1000,\n"
    printf "        1500,\n"
    printf "        2000\n"
    printf "    ]\n"
    printf "}"
} >> ../album.json

# pragma 14. Converting to webp
webpc -r

# pragma 15. Copying the files in their right directories
start_spinner 'Copying files...'
mv -n ./*.jpg ../jpeg/
mv -n ./*.jpeg ../jpeg/ 2>/dev/null
mv -n ./*.webp ../webp/
stop_spinner $?

# pragma 16. Removing the temporary directory
sleep 5 # To allow the move buffer to clear; caused an issue were the temp directory would not be removed by the end of the script.
cd ../
rm -r ./"$TEMP"

# pragma 17. Exiting the script
clear
printf "\033[0;32mScript has executed!\n"
exit 0
